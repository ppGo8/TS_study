# ts高阶应用

## infer

### `infer`介绍

- `infer`定义：

  - 用在包含`extends`关键字的条件语句中，以**`infer` + 占位符出现**，等到使用时**推断**出来**具体类型**

  - 用 `infer` 声明一个**类型变量**，并且使用该**类型变量**

- `infer`作用：可以帮助程序员拿到某个类型中的**部分类型**

- `infer`使用场景：

  - 拿到满足条件的`inter`后对应的类型

    ```ts
    // 【场景1】：满足条件就拿到infer后的类型
    type CusFtnType = (params: Customer) => string;
    // 需求：拿到CusFtn类型中 参数/返回值的类型
    // 1.1 拿到参数类型
    // 满足?前条件语句,返回推断出来的参数类型T
    type CusParaType = CusFtnType extends (params: infer T) => string ? T : never
    // 不满足?前条件语句,返回never
    type CusParaType2 = CusFtnType extends (params: infer T) => number ? T : never 
    // 1.2 拿到返回值类型
    // 返回推断出来的类型T
    type CusRetuType = CusFtnType extends (params: Customer) => infer T ? T : never 
    // 返回推断出来的类型T
    type CusRetuType3 = CusFtnType extends (params: any) => infer T ? T : never 
    // 返回never
    type CusRetuType2 = CusFtnType extends (params: Customer) => infer T ? T : never 
    
    // 1.3 语法练习：同时拿到上述两种类型
    type CusALLType = CusFtnType extends (params: infer P) => infer R ? P | R : never
    ```

  - **结合泛型，得到通用代码**

    ```ts
    // 拿到任一函数类型的参数
    type ParamsType<T> =  T extends (Params: infer P) => any ? P : never
    type cusParamsType = ParamsType<CusFtnType>
    
    // 拿到任一数组类型的元素类型
    type arrayType<E> = E extends (Array<infer P>) ? P : never
    type arrayString =  arrayType<Array<string>>  // 注意里面需要写的完整的数组类型
    ```

- 区分`infer`和泛型
  - 泛型在使用前需要使用前括号声明，而`infer`不需要

### vue3中的`infer`

```ts
// 函数作用：解ref获得原始值
// uref(ref(3)) 返回3 类型number
// uref({a: 1, b: 2}) 返回{a: 1, b: 2} 类型({a: number, b: number}
export function uref<T>(ref: T) : T extends Ref<infer V> ? V : T {
	return isRef(ref) ? (ref.value as any) : ref
}
```

- 参数`(ref: T) `

  泛型`T`，类型在调用处时给出，由传入值决定

- `T extends Ref<infer V> ? V : T`

  判断条件 ` T extends Ref<infer V> ` 

  如果类型`T`是`Ref<infer V>`下的一个类型`V`，则返回`V`，不是则返回数据的原始类型`T`

  > - 如果传入的不是`ref`数据，则返回原数据。**业务逻辑** 返回原数据的思想

- ` (ref.value as any)`

  在函数声明名，`ref`的类型为`T`，并没有具体化，此时的类型为`unkown`也不知道其上是否有`value`属性

  因此需要`as any`避免`ts`报错

  > `any`改用还是得用

##  类型体操

### 基本介绍

- 类型体操：常用来描述在 TypeScript 中进行高级或复杂的**类型操作和推断的过程**。
  - 类型体操可以包括使用泛型、条件类型、映射类型、交叉类型、联合类型等高级类型特性

- 类型体操一般不复杂，复杂情况：类型体操中包含了类型递归

### `in keyof`

- 作用：遍历获得对象类型的所有``key`

- 代码：

  ```ts
  // for ... in 遍历获取对象变量中的所有key
  // xxx ... in keyof 遍历获得对象类型的所有key
  
  interface Person {
    name: string,
    age: number,
  }
  
  // 以下三种方法类型等价
  type PerKeyValsType = {
    [p in keyof Person]: Person[p];
  }
  
  type PerKeyValsType2 = {
    [p2 in 'name' | 'age']: Person[p2]
  }
  type PerKeyValsType3 = {
    ['name']: string,
    ['age']: number
  }
  
  ```

  ```ts
  // 通过的keyof方法
  type PerKeyValsComType<T> = {
    [p in keyof T]: T[p];
  }
  // PerKeyValsPersonType的类型和上面的等价
  type PerKeyValsPersonType = PerKeyValsComType<Person>
  ```

## 条件类型

### 介绍

- 语法：

  - 条件类型的语法使用了 `extends` 关键字来进行条件判断

  - 条件类型通常用于根据一个条件的真假来选择不同的类型

    ```ts
    type MyType<T> = T extends SomeConditionType ? TrueType : FalseType;
    ```

    - `MyType<T>` 是条件类型的名称，它接受一个泛型参数 `T`。
    - `T extends SomeConditionType` 是条件部分，它判断泛型参数 `T` 是否满足某个条件（`SomeConditionType`）。如果满足条件，那么这个条件成立。
    - `TrueType` 是在条件成立时返回的类型。
    - `FalseType` 是在条件不成立时返回的类型。

### 联合类型比较规则

- 在写死的联合类型的比较规则中，即不适用泛型的比较规则：

  <font color=red>会使用**联合类型整体**和后面的类型比较</font>

- 给泛型传入联合类型

  <font color=red>会逐个取出传入泛型的联合类型中的某个类型，和后面的类型作比较，属于后面的任意一个类型即符合条件，返回这个类型；**满足几个类型返回几个类型**</font>

```ts
// 1.写死联合类型的条件类型
type TestType = string extends string | number ? string : never // string
type TestType2 = string | boolean extends string | number ? string : never // never

// 2.使用泛型的联合类型的条件类型
type ConType<T> = T extends string | number ? T : never

type ConType1= ConType<string> // string
type ConType2= ConType<string | boolean>  // string
```

### 联合类型应用

- 作用：项目更灵活。

- 代码

  以下面代码为例，如果想改传入的内容为`Array`，那么就不必修改所有，只需要修改一处。

  ```ts
  // 该函数使用泛型约束限制传入的参数为object类型
  // 泛型约束写在前括号<>中
  function cross<T extends object,U  extends object>(obj1: T , obj2: U): T & U {
    return {} as T & U;  // 业务逻辑 pass
  }
  
  // 需求：只修改一处代码实现 规定传入类型为Array,即动态判断类型
  // 解决方法: 使用条件类型代替泛型约束
  type ConType<T> = T extends Array<any>?  T : never // 【重点】只需要修改extends关键字后的内容即可规定传入参数的类型
  function cross2<T,U>(obj1: ConType<T> , obj2: ConType<U>): T & U {
    return {} as T & U;  // 业务逻辑 pass
  }
  
  export {}
  ```

  > **`extends`关键字可以用的地方**
  >
  > - 类继承，子类继承父类
  >
  > - 类型约束，规定该泛型必须满足的条件，**要写在定义类型的尖括号中**
  >
  > - 条件约束，和条件`?`一起使用
  >
  >   如果不适用条件`?`或者尖括号，单独使用`extends`会报错

### 条件类型复杂应用

- 给已有类型动态追加一个乐行

  ```ts
  // 需求：给下面的接口动态追加属性,满足未来的使用
  interface Person {
    name: string,
    age: number
  }
  
  // 给类型T追加K: V
  // 只考虑传入字符串属性名的形式
  type AddAttrToIner<T, K extends string, V> = {
    // P in ((keyof T) | K)
    [P in keyof T | K]: P extends keyof T ? T[P] : V // 【重点】
  }
  
  type Test = AddAttrToIner<Person, 'addr', string>
  ```

## `in keyof`/`keyof`

### `in keyof`——扁平化模块命名

```ts
// 需求：得到路由规则下所有"父模块/子模块"的字面量,即"menu/setMenu" | "menu/setMenuList" | "tabs/setTab" | "tabs/setTabList"
type Modules = {
  menu : {
    setMenu: (index: string) => string,
    setMenuList: (index: string) => string,
  },
  tabs: {
    setTab: (index: string) => void,
    setTabList: (index: string) => void,
  }
}
// 1.模板字符类型
// 【问题】 模板中不能出现普通的泛型,会报错 【解决方法】 &string
type MB<T, U> = `${T & string }/${ U & string}` // 【重要】如果传入联合类型是逐个处理的；字符串常量类型
type TestMB = MB<'menu' | 'tab', 'create' | 'list' > // "menu/create" | "menu/list" 

// 2.拿到父模块的属性名
type moduleParnetKeys<T> = {
  [Key in keyof T]: Key
}

// 3.父模块和子模块 属性名【重点】
type moduleConnectKeys<T> = {
  [Key in keyof T]: MB<Key, keyof T[Key]>
}[keyof T]// 在一个对象类型后写[keyof T]作用：删除key,所有的值形成新的联合类型

// 验证
type ModulesType_ = moduleConnectKeys<Modules> 
// 写了[keyof T] "menu/setMenu" | "menu/setMenuList" | "tabs/setTab" | "tabs/setTabList"
// 不写[keyof T]  { menu: "menu/setMenu" | "menu/setMenuList"; tabs: "tabs/setTab" | "tabs/setTabList";}
```

### keyof不能直观看到属性值的问题

```ts
interface Person {
  name: string,
  age: number,
  addr: string,
}
// 【问题】直接获取keyof鼠标悬浮显示 keyof Person
type keyType = keyof Person; 
// 【解决方法】借助泛型和条件,泛型处理联合类型是逐个处理,逐个返回,因此可以看到
type getKeyofType<T> = T extends any ? T : never
type keySeenType = getKeyofType<keyof Person> // 鼠标悬浮 "name" | "age" | "addr"
```

## ts常用高级类型

### Extract

#### 基础介绍

- 语法：是条件类型的一个简写

  - 底层代码

    ```ts
    type Extract<T, U> = T extends U ? T : never;
    ```

    - `T` 是要操作的类型，通常是一个联合类型。

    - `U` 是目标类型，用于提取满足条件的子类型。

    - 如果 `T` 是 `U` 的子类型，则返回 `T`，否则返回 `never`。 

      >如果是T是联合类型，那么是T联合类型下**每个类型逐个比较是否为U子类型**，谁满足就返回谁。
      >
      >多个满足返回满足类型的联合类型。

- 作用：用于从联合类型`T`中提取满足特定条件的子类型。

#### 应用场景

```ts
// 应用场景 8chapter-6
// 【原代码】
function cross<T extends object,U  extends object>(obj1: T , obj2: U): T & U {
 return {} as T & U;  // 业务逻辑 pass
}

// 【优化】 使用extract
type ConType<T> = Extract<T,object> 
function cross2<T,U>(obj1: ConType<T> , obj2: ConType<U>): T & U {
 return {} as T & U;  // 业务逻辑 pass
}
```

### Exclude

#### 基础介绍

- 语法：是条件类型的一个简写

  - 底层代码

    ```ts
    type Exclude<T, U> = T extends U ? never : T;
    ```

    - `T` 是要操作的类型，通常是一个联合类型。

    - `U` 是目标类型，用于排除满足条件的子类型。

      >T联合类型逐个比较。

- 作用：`Exclude` 在实际应用中常用于**过滤或排除`T`**某个联合类型中的特定类型。

#### 应用场景

`````ts
type Animal = "Cat" | "Dog" | "Bird";
type NonBird = Exclude<Animal, "Bird">; // NonBird 将被推断为 "Cat" | "Dog"

type SuccessCallback = (result: string) => void;
type ErrorCallback = (error: Error) => void;
type Callback = SuccessCallback | ErrorCallback;

type NonErrorCallback = Exclude<Callback, ErrorCallback>;// NonErrorCallback 将被推断为 (result: string) => void

`````



### Record类型

#### 基本介绍

- 基本语法：

  - 使用：

    ```ts
    // 第一个参数代表对象的属性,第二个参数代表值类型
    type objType = Record<'name'| 'age' | 'addr', string | number>
    type objType = Record<string, string | number> 
    type objType = Record<number, string | number>    
    type objType = Record<symbol, string | number>    
    ```

    - 第一个参数代表对象的属性，仅支持传入三种类型：`string`/`number`/`symbol`

      传入`string`，会被底层解析为索引签名`[x: string]: 属性类型`,属性名可以为 字符、数字、symbol。**因此Record类型可以兼容数组类型**

      传入`number`，会被底层解析为索引签名`[x: number]: 属性类型`,属性名可以为 数字、symbol

      传入`symbol`，会被底层解析为索引签名`[x: symbol]: 属性类型`, 属性名可以为 数字、symbol

    - 第二个参数代表值类型

  - 底层代码

    ```ts
    type Record<K extends keyof any, T> = {
        [P in K]: T;
    };
    ```

    > **底层规则**
    >
    > `keyof any` 得到的值为： `symbol | number | string `

- 作用：用于创建具有**指定属性和属性值类型**的对象类型。、

- 使用场景：

  `Record`是`object`的优化，可以使用`object`的地方都可以使用它。

  ```ts
  // 1.object场景1 基本对象变量类型
  // 定义一个变量为object类型时, 没办法使用点语法获取属性
  // 所以一般不使用object定义一个变量类型
  let obj1: object =  {
    name: 'pp',
    age: 24,
  }
  obj1.name // 报错: 类型“object”上不存在属性“name”
  
  // 2.object场景2 函数参数
  // 函数参数传递对象时,经常使用objcet
  function addObj(obj: object) {
    // 函数体中无法使用点语法访问属性
    // object类型对属性名也没有限制
    console.info(obj);
  }
  addObj({  name: 'pp',age: 24,})
  
  
  // 解决方案：1.使用接口 2.Record
  function test(obj: Record<'name'| 'age' | 'addr', string | number> ) {
    console.info(obj.name);
  }
  test({ name: 'pp',age: 24, addr: '广东广东'})
  ```

#### 应用场景

> **遍历实现深拷贝**

```ts
/**
 * 判断传入引用类型为对象还是数组
 * @param data 
 * @returns {boolean} true:对象 false:数组
 */
function isObject(data: Record<string, any> | baseType) { // Record<string, any> 可以接受数组和对象
  return Object.prototype.toString.call(data) === "[object Object]"
}

/**
 * 实现深拷贝
 */
type baseType = string | number | symbol; 
function deepCopy(data: Record<string, any> | baseType): any {
  if(isObject(data)) {
    if(Array.isArray(data)){
      return data.map(item => deepCopy(item));
    }
    const copy: Record<string, any>  = {};
    for (const key in data as Record<string, any> ) {
      if(Object.prototype.hasOwnProperty.call(data, key)) {
        copy[key] = deepCopy((data as Record<string, any>)[key]);
      }
    }
    return copy;
  } else {
    return data
  }
}
const originalObject = {
  name: 'John',
  age: 30,
  nested: {
    city: 'New York',
    country: 'USA',
  },
  hobbies: ['reading', 'traveling'],
};

const copiedObject = deepCopy(originalObject);
originalObject.nested.city = 'pp狗';
console.log(originalObject);
console.log(copiedObject);

```

### Pick

#### 基础介绍

- 作用：内置工具类型，用于从**给定类型**中选择指定的**属性**，**并创建一个新的类型**

  底层代码：

  ```ts
  type Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };
  ```

- 语法：

  ```ts
  type NewType = Pick<OriginalType, 'Prop1' | 'Prop2' | 'Prop3'>;
  ```

#### 代码

```ts
// 1.获取接口属性
interface Book {
  ISBN: string,
  name: string,
  price: number,
  publisher: string,
}

type SubBook = Pick<Book, 'ISBN'| 'name'> // type SubBook = { ISBN: string; name: string; }
```

```ts
// 2.获取类
class Person {
  name!: string
  age!: number
}
type SubPerson = Pick<Person,'name' | 'age'> // type SubPerson = { name: string; age: number;}
```

### in

- `ts`中`in`别名：映射类型

- 常用场景：

  - `for...in` 循环：

    `for (let key in object)` 可以用来迭代**对象的属性名**。

    > 注意：`for...in` 循环不仅遍历对象自身的属性，**还会遍历它的原型链上的属性。**
  
  - **类型守卫**，判断**对象/类型**是否含有某个属性名返回布尔；配合`if`语句
  
    ```ts
    if ('size' in shape) {
      // shape 是 Square 类型
      return shape.size * shape.size;
    } 
    ```
  
  - **映射类型**，用于创建新类型；配合方括号
  
    ```ts
    type Flags = { 
      option1: boolean; 
      option2: boolean; 
      option3: boolean };
    type NullableFlags = { 
      [K in keyof Flags]: boolean | null 
    };
    ```

### Omit

#### 基本介绍

- 作用：内置工具类型，用于从一个**类型中**排除**指定属性*，创建一个新的类型

  和`Pick`相反

- 语法

  ```ts
  type NewType = Omit<OriginalType, 'Prop1' | 'Prop2' | 'Prop3'>;
  ```

  - `OriginalType` 是要从中排除属性的原始类型。
  - `'Prop1' | 'Prop2' | 'Prop3'` 是一个字符串字面量联合类型，表示要排除的属性的名称列表。

#### 代码示例

```ts
interface Person {
  name: string,
  age: number,
  height: number,
  weight: number,
}

type SubPerson2 = Omit<Person, 'name'>
// 手动实现Omit
// type Omit<T, K extends keyof T> = {
//   // as的作用: 每次执行完一次as前的遍历,就会执行一次as后的判断条件
//   [P in keyof T as P extends K ? never : P]: T[P]
// }
type Omit<T, K extends keyof T> = {
  // 遍历T上的所有属性,若是属于传入的K,则不获取该属性和属性值
  [P in keyof T as Exclude<P,K>]: T[P]
}
type SubPerson3 = Omit<Person, 'name'>

```



> 区分`Exclude`，`Extract`，`Pick`，`Omit`
>
> - `Exclude`，`Extract` 多用于操作联合类型
> - `Pick`，`Omit`多用于处理对象类型和接口、类

## 工具类型综合应用

- 需求：

  1. 获取接口中的所有方法,不需要属性; 
  2. 修改所有属性名,比如在前面加do

  ```ts
  interface Todo {
    title: string
    completed: boolean
    description: string
    add(): number
    del(): number
    upt(): number
  }
  ```

  ```ts
  type Degere<T> = {
    // 1. as : P要显示要同时满足as前面和后面的条件
    // 2. ${ P & string } : 这种写法才能正常在模板字符串中使用泛型
    // 3. Capitalize : 将首字母大写
    [P in keyof T as T[P] extends Function ? `do${ Capitalize<P&string> }`: never]: T[P] }
  
  // { doAdd: () => number; doDel: () => number; doUpt: () => number;}
  type DegereTodo = Degere<Todo> 
  ```

- <font color=red>优化</font>：

  - 上述代码`Degere`允许传递任何类型，**但实际应该只允许传递对象类型**

  - `T extends Record<string, any>`**实际上允许传递对象和数组**

    **允许传递对象必允许传递数组**

    >**如果允许传递数组**,会将数组原型上的方法修改为do+Xx的格式，出现了很多奇怪的内容。

  - 修改方法：允许传递数组，但如果传递数组进来返回空值

    因此还需要在`as`判断处，如果为数组类型那么返回`never`

  ```ts
  interface Todo {
    title: string
    completed: boolean
    description: string
    add(): number
    del(): number
    upt(): number
  }
  
  // 优化： 
  // 1.只允许泛型接受对象类型：T extends Record<string, any>
  //    Record<string, any>允许接受对象和数组,**没办法禁止传递数组进来**； **允许对象必将允许数组**
  // 2.允许接受数组,但是返回空对象
  //   判断一个类型是否继承数组类型: T extends Array<any>，这个可以只接受数组
  //   解决方法: 传入数组时,返回空对象
  type Degere<T extends Record<string, any>> = {
    [P in keyof T as T extends Array<any> ? never : T[P] extends Function ? `do${ Capitalize<P&string> }`: never]: T[P] 
  }
  type DegereTodo = Degere<Array<any>>  // {}
  ```

## 一个诡异的类型映射

- 类型映射`in`后允许的类型:  `string` `number` `symbol` 或**字面量**及**联合类型**

  - **联合类型**：

    - 一般来说都是由前面的三种类型组成的联合类型

    - 但是可以**对元素为类型的联合类型**进行强制映射`as`，映射语句中当作字面量看待，映射后当作类型使用

- 如果是`[P in string]: value` 会被解析为 **索引类型签名** `[x: string]: value` 【记忆即可】

- 代码实现：

```ts
// 现有如下两个对象类型
type MouseEvent = { event: 'click', x: number, y: number,}
type KeyEvent = { event: 'KeyUp', key: number}
// 需求：得到如{ click: (event: MouseEvent) => any;  KeyUp: (event: KeyEvent) => any;}形式的类型
// 分析: 待求的类型中：使用了属性值click/KeyUp, 使用了类型名MouseEvent/KeyEvent 复杂
// 怪异之处：
//   1. 传给泛型Events的 是一个MouseEvent和KeyEvent联合类型;
//      泛型在处理来联合类型时，是逐个对每个处理的。
//   2. 对象类型的联合类型的结果值为： 二者共有属性名,属性值为相同属性名下属性值的联合类型
//      MouseEvent | KeyEvent = { event: 'click' | 'KeyUp' 
//   3.一般来说,in 语句后只能接string/number/symbol类型
//     但是可以使用as语句规避ts编译错误
// 解决方法：
//   1. 使用as规避ts编译错误,允许in语句遍历 元素为类型的联合类型,这样遍历得到的值就为某个类型；
//      (从何获得了单个类型的类型名,还可以使用点语法获得下面的属性)
//   2. 实际运行逻辑：
//      2.1 as规避编译报错,运行时in后不是规定类型,所以执行到了as,
//      2.2 执行到as后发现必须知道Event是什么,因此重新返回in将强制映射联合类型
//         (可以理解为将其作为字符串联合类型,不过后面它还可以使用点语法)
//      2.3 使用[]语法访问每一个遍历得到的类型下的属性
type EventFunction<Events extends Record<string,any>, EvnetKey extends keyof Events> = {
  // 下面两种写法等价
  // [Event in Events as Event extends Events ? Event[EvnetKey]: never]: ( event : Event) => any
  [Event in Events as Event[EvnetKey]]: ( event : Event) => any
}
type Test = EventFunction< MouseEvent| KeyEvent, 'event' >  // 条件要求


export {}
```

## ts高级辅助类型

### Required和Partial

- 作用：

  - `Required`: 内置类型，把所有可选项转成必选项

  - `Partial`：内置类型，把所有必选项变成可选项

- 代码：

  ```ts
  interface Todo {
    readonly title: string
    completed: boolean
    description: string,
    // 可选类型
    date?: Date,
    publisher?: string,
  }
  
  // 需求: 
  // 1.不改变原接口的情况把可选属性变为必选属性 -? Required
  // 2.不改变原接口的情况把所有属性变为可选属性 ? Partial
  // type TodoMust = Required<Todo>
  // type TodoSelected = Partial<Todo>
  
  // 底层实现
  type Required<T> = {
    [P in keyof T]-?: T[P]
  } 
  type Partial<T> = {
    [P in keyof T]?: T[P]
  } 
  type TodoMust = Required<Todo>
  type TodoSelected = Partial<Todo>
  export {}
  ```

### Readonly

- 作用：内置类型，类型所有属性设置为只读

- 代码

  ```ts
  // 3.属性全部设置为只读 readonly
  // 底层
  type Readonly<T> = {
    readonly[P in keyof T]?: T[P]
  }
  type TodoReadonly = Readonly<Todo>
  ```

  



