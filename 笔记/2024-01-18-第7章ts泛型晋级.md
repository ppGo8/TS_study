# 泛型晋级

## 为什么需要函数重载

- 举例

  ```ts
  // 现有如下数据类型数据
  enum MessageType {
    Audio = 'Audio',
    Image = 'Image',
  } 
  type Message = {
    id: number,
    type: MessageType,
    message: string
  }
  let messageInfo: Message[] = [
    {
      id: 1,
      type: MessageType.Image,
      message: 'hello'
    },
    {
      id: 2,
      type: MessageType.Image,
      message: 'pp'
    },
    {
      id: 3,
      type: MessageType.Audio,
      message: 'pp'
    },
    {
      id: 4,
      type: MessageType.Audio,
      message: 'pp'
    }
  ]
  ```
  
  - 需求：根据``id`或者`type`来搜索`messageInfo`中符合条件的数据
  - 分析：
    - `id`唯一，所以返回的是对象或`undefined`
    - `type`不唯一，所以返回的是数组对象
  
  ```ts
  // 一般做法
  function findMesaage(condition: number | MessageType): Message| Message[] | undefined {
    if(typeof condition === 'number') {
      return messageInfo.find( item => item.id === condition )
    } else {
      return messageInfo.filter( item => item.type === condition)
    }
  }
  // 此时有以下缺陷
  // 1.鼠标悬浮在findMesaage函数调用处,提示的类型为函数调用处的全部返回值类型 而不是具体的实际的需要的返回值类型
  // 2.函数调用后使用点语法 无法提示该类型下的正确属性 (自己手写使用也会报错)
  // 返回值是联合类型，点语法只会返回联合类型的公有属性
  console.info(findMesaage(1))
  console.info(findMesaage(MessageType.Audio))
  ```

- 解决上述问题的方法

  - 方法1：类型断言【不推荐】

    ```ts
    // 如果想只用某个类型下的属性和方法： 类型断言
    console.info((findMesaage(1) as Message).message)
    console.info((findMesaage(MessageType.Audio) as Message[])[0]);
    ```

    > 类型断言只能解决部分问题,允许你使用对应类型的属性和方法；
    >
    > 但是返回函数还是依旧不会提示，而且很冗长
    >
    > **类型断言**应该是到最后万不得已的写法

- 方法2：<font color=red>**函数重载**</font>

  见下一节。

## 函数重载

- 函数重载定义：

  一组具有相同名字、不同参数列表且返回值无关，具有一个或多个重载签名、一个实现签名一个函数体的函数。

  

- 函数重载语法：

  - 多个重载签名 ：
    - 参数不同：类型、个数、顺序
    
  - 一个实现签名 ：
    - 必须能够**兼容全部的重载签名**，兼容形参处、返回值处
      - 同一位置不同类型的兼容：**用联合类型或`any`**
      - 不同个数的兼容：**非必须出现的用`?`**
      - 不同顺序：**其实还是类型不同**，且实现签名和各个重载签名处的形参名不必一定相同
    - 只能有一个
    
  - 一个函数体

    

- 各部分作用：

  - 重载签名：**使得`ts`精确的显示函数的输入和输出**
    - 鼠标悬浮在函数调用处时，会准确提示出函数传入值和返回值类型
    - 在使用点语法时可以获取准确获得对应类型的属性
  - 实现签名：将**所有的输出输入做一个全量的定义**，防止`ts`报错
  
  
    - 函数体：函数**功能实现的全部逻辑**
  
      通常函数体中使用`typeof`等类型守卫判断传入参数的类型，来执行不同的代码。
  
      
  


- 函数重载实现逻辑：

  - 首先检查实现签名、函数体
  - **执行函数实际上是执行某个重载签名+函数体**，跳过了实现签名。

> **细节**
>
> - 类型守卫执行哪一个分支的代码，是根据关键字的`if`里面的条件来判断的
> - 而不是程序员通过形参传进来的类型
>
> - 比如数字枚举和数字类型，使用`typeof`的结果都为数字类型、会进入一个分支

- <font color=red>函数重载重新实现上述需求</font>

  ```ts
  function findMesaage(condition: number): Message | undefined
  function findMesaage(condition: MessageType): Message[]
  function findMesaage(condition: number | MessageType): Message | undefined | Message[]  {
    if(typeof condition === 'number') {
      return messageInfo.find( item => item.id === condition )
    } else {
      return messageInfo.filter( item => item.type === condition)
    }
  }
  // 此时鼠标悬浮在函数调用处时,会提示具体的某一个函数重载的返回值类型
  // 可以访问该某一具体返回值类型下的属性和方法
  console.info(findMesaage(1)?.id)
  console.info(findMesaage(MessageType.Audio).length)
  ```


## 泛型函数

### 基础知识

- **泛型函数声明：**

  ```ts
  function identity<T>(arg: T): T {
      return arg;
  }
  ```

- **泛型函数调用：**

  ```ts
  // 显示指定泛型类型
  let result = identity<string>("Hello");
  // 让ts根据传入的参数自动推导【常用】
  let result = identity("Hello");

- **其他知识点**

  之前讲过的泛型的知识点，在这里依旧适用，如：

  - 泛型约束`extends`
  - 默认泛型`ts`

### 代码举例

```ts
/**
 * 快速排序算法
 * @param arr 可以排序数字数组、字符串数组
 * @returns 
 */
export default function quickSort<E>(arr: Array<E>): Array<E> {
  if (arr.length <= 1) {
      return arr;
  }

  const pivotIndex = Math.floor(arr.length / 2);
  const pivot = arr[pivotIndex];

  const left:Array<E> = [];
  const right:Array<E> = [];

  for (let i = 0; i < arr.length; i++) {
      if (i === pivotIndex) {
          continue;
      }

      if (arr[i] < pivot) {
          left.push(arr[i]);
      } else {
          right.push(arr[i]);
      }
  }

  return [...quickSort(left), pivot, ...quickSort(right)];
}

// 示例1：数字数组
// const unsortedArray = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
// const sortedArray = quickSort(unsortedArray);
// console.log('Unsorted Array:', unsortedArray);
// console.log('Sorted Array:', sortedArray);

// 实例2: 字符串数组
// const unsorteStrArr = ['bac', 'abc', 'cfd', 'xyz'];
// const sortedStrArr = quickSort(unsorteStrArr);
// console.log('Unsorted Array:', unsorteStrArr);
// console.log('Sorted Array:', sortedStrArr);

```

## 泛型函数重载

- 泛型函数重载的作用和函数重载一样，**都可以更精确的显示输出和输出**
- 这一节通过代码展示 泛型函数重载语法

### 泛型函数实现排序

```ts
// 数字、字符串数组排序 
import quickSort from '../7chapter/3-泛型函数'  // 上一节泛型函数处定义的方法

/**
 * 一个泛型函数: 实现字符串自排序、中文数组排序、数字数组排序、字符串数组排序(同时对元素内容进行自排序)
 * @param data 
 * @returns 
 */
function sort<T>(data: string | Array<T>): string | Array<T> {
  if (typeof data === 'string') {
    return strSort(data);
  } else if(data instanceof Array) {
    if (isChinese(data)) {
      return chineseSort(data)
    }
    const newArr = data.map((item) => {
      return typeof item === "string" ? strSort(item) : item
    })
    return quickSort(data)
  }
  throw new Error(`data must be string or array. ${data}`);
}
// 现在使用点语法,只能访问string和数组的公共方法
// 但是我们明确知道传入string就会返回string,传入Array就会返回Array，因此可以继续使用函数重载优化
console.info(sort('cba'));
console.info(sort(['张三', '李四', '王五']));
console.info(sort(['321', '456', '987']));

// 准备工作
/**
 * 中文数组排序
 * @param arr 
 * @returns 
 */
// 该函数的参数返回值类型为确定的string[],另外一个sort函数中调用此函数且return了该函数的返回值
// 因此sort的返回值就需要写一个 string[]；
// 而上面我们看到sort处已经有了一个Array<T>,因此改造这个函数传入传出的值都为泛型的形式
// function chineseSort(arr: Array<string>): string[] { 
//   return arr.sort((first, second) => {
//       return first.localeCompare(second, 'zh-CN') 
//   })
// }
export function chineseSort<T>(arr: Array<T>): T[] {
  return arr.sort((first, second) => {
         // 在函数声明处,first和sencond的类型为T,所以编译器会报错没有localeCompare方法;所以要进行类型断言
         // 为as any 或者 string;
         // 因此在函数传入参数处不如直接写string
      return (first as any).localeCompare(second, 'zh-CN')  
  })
}
/**
 * 正则表达式，判断是否是中文数组
 * @param arr 
 * @returns 
 */
export function isChinese<T>(arr: Array<T>): boolean {
  const pattern = /[\u4e00-\u9fa5]+/g;
  return arr.some((item: any) => {
      return pattern.test(item)
  })
}
/**
 * 字符串自排序
 * @param str 
 * @returns 
 */
export function strSort(str: string):string {
  const strArr = str.split('');
  return quickSort(strArr).join('');
}
```

### 泛型函数重载实现排序

```ts
import quickSort from '../7chapter/3-泛型函数' 
import {chineseSort, isChinese, strSort} from '../7chapter/4-泛型函数实现排序'

/**
 * 实现字符串自排序、中文数组排序、数字数组排序、字符串数组排序(同时对元素内容进行自排序)
 * 且在调用函数时能够精确的输出返回内容的数据类型;而方便使用点语法
 * @param data 
 * @returns 
 */
function sort(data: string): string
function sort<T>(data: Array<T>): Array<T>
// 下面两种实现签名都可以,一种是全部写any(包括泛型);一种是把所有支持的参数类型写成联合类型的方式
// function sort<T>(data: string | Array<T>): string | Array<T> {
function sort(data: any): any {
  if (typeof data === 'string') {
    return strSort(data);
  } else if(data instanceof Array) {
    if (isChinese(data)) {
      return chineseSort(data)
    }
    const newArr = data.map((item) => {
      return typeof item === "string" ? strSort(item) : item
    })
    return quickSort(data)
  }
  throw new Error(`data must be string or array. ${data}`);
}

// 再使用点语法时或鼠标悬浮在调用函数处时,就可以精确显示返回值类型和它的属性和方法了
console.info(sort('cba'));
console.info(sort(['张三', '李四', '王五']));
console.info(sort(['321', '456', '987']));
```

> 由泛型函数重载得到的思考：
>
> - 什么时候才能写成重载？
>
>   一个函数的不同输入类型会返回不同的输入类型，即**输入输出可以分组**：
>
>   以`sort`函数为例
>
>   - 组1：传入`string`，则返回`string`
>   - 组2：传入`Array[T]`，则返回`Array[T]`
>
> - 什么时候可以使用泛型？
>
>   只需要考虑**传入参数**，如果传入参数自己本身支持多种类型(基础类型是一组、引用类型是一组)，那么就可以使用泛型。
>
>   （如果不使用泛型就要使用联合类型接受，点语法和悬浮就只能提示联合类型支持的属性）
>
>   以`sort`函数为例，其中引用类型`Array`支持数字和字符串，因此可以使用泛型
>
> - **在一个函数``fn`中调用另外一个函数`subfn`，并且`fn`函数`return subfn()`**，那么此时`fn`函数<font color=red>的返回值就要兼容`subfn()`返回值类型。</font>
>
>   - 注意：
>
>     - `Array<T>`是不兼容`string[]`的
>
>     - 即`fn`的返回值类型为`Array<T>`,`subfn`的返回值类型为`string[]`
>
>       会报错`fn`返回值类型不支持`string[]`
>
>     - 解决方法：修改`subfn`为`Array<T>`即可

## 泛型工厂函数

### 基础知识

- 泛型工厂函数定义：

  - 可以代表任意一个**类构造函数`constuctor`**的函数、
    - 首先是函数类型
    - 其次不是普通的函数类型，是代表**类的构造函数**的类型

- 泛型工厂函数作用：

  - 可以使用泛型来创建任意一个类的实例对象

  - 允许我们根据调用时传递的类型参数**动态创建**不同类型的实例对象

    

- 类具有双重的双重性质

  - 作为一个类型：

    - **将类作为变量的类型、参数的类型**

    - **当使用`new`实例化了一个类，<font color=red>也就创建了一个具有相应类型的对象</font>**

    ```ts
    class MyClass {
        // 类的定义
    }
    
    let instance: MyClass; // 类声明变量的类型
    instance = new MyClass(); // 实例化类
    ```

  - 作为一个**类的构造函数对象变量(注意不是类型,而是变量)**，指向<font color=red>对应的`constructor`</font>

    - `new () => 类名`为指定类名的构造函数类型

    


### 代码

- 类名作为构造函数变量

  - 下面的代码：**创建了构造函数类型`new () => any/T/具体类名`**
  - 下面的代码：**将一个类作为构造函数变量赋值给了另外一个变量**

  ```ts
  class Bank {
    public name: string = '硅谷银行';
    static count : number = 100;
  
    constructor(_name: string) {
      this.name = _name;
    }
  
    loan():void {
      console.log(this.name + '已放贷...')
    }
  }
  
  
  // 所有类的构造函数类型
  type ConstructorAllType = new (...args: any) => any
  // Bank类的构造函数类型
  type ConstructorBankType = new (...args: any) => Bank // 在类型处,使用new代表构造函数
  
  // let instanceBank: ConstructorBankType = new Bank('pp') // 这样是错的,因为实例变量的类型为这个类名Bank,而不是构造函数的类型
  let cbInstance: ConstructorBankType = Bank // 构造函数
  // 【重点】此时new cbInstance和Bank是一样的效果;已经没有区别了
  console.log(new cbInstance('pp1')) 
  console.log(new Bank('pp2'))
  ```

- 泛型工厂函数**根据参数实现动态创建类实例对象**【重点】

  ```ts
  class Bank {
    public name: string = '硅谷银行';
    static count : number = 100;
  
    constructor(_name: string) {
      this.name = _name;
    }
  
    loan():void {
      console.log(this.name + '已放贷...')
    }
  }
  // 以下type和Interface的写法是等价的
  type bankCtorType = new (...args: any) => any;
  interface bankCtorInter{ // 泛型工厂函数类型还可以用接口的方式表示
    new (...agrs: any): any
  }
  
  // 需求: 创建任意一个类的实例化对象时, 页面上输出内容
  // 方法1：在所有类的构造函数中手动写 【不现实】
  // 方法2：泛型工厂函数 【推荐】
  // 以下三种写法等价
  // function createFactorConstructor(Constructor: new (...args: any) => any) {
  // function createFactorConstructor(Constructor: bankCtorType) {
  function createFactorConstructor(Constructor: bankCtorInter, ...args: any) {
    console.log('创建对象...');
    return new Constructor(args.join(','));
  }
  const ppInstance = createFactorConstructor(Bank, '花花');
  console.info(ppInstance)
  export {}
  ```

  

>**铺垫**
>
>在装饰器内部想要创建一个类的时候，必须使用构造器的工厂函数、

## 交叉类型

### 交叉类型：

- 原理：

  - 把两个相同类型放在一起求**并集**

  - 把两个不同类型放在一起**尝试求并集**

    <font color=red>要求变量**同时满足这些并集规则**</font>

    > 联合类型只需要满足其中一个类型规则

- 使用场景

  一般交叉对象类型和接口

  ```ts
  // 交叉两个对象类型返回两个对象类型的并集
  type P1 = {a: number, b: number};
  type P2 = {c: string, d: string};
  type P3 = P1 & P2;
  // 只能在使用时 根据ts报错的提示 查看交叉效果
  // 把鼠标放在P3处没有具体的类型显示 只显示P1 & P2
  let p3:P3 = {
    a: 123,
    b: 456,
    c: '123',
    d: '456'
  }
  ```

### 通用交叉方法

- 语法：**主要使用泛型**

- 作用：可以接受多个对象，将它们合并为一个新对象，具有所有输入对象的属性和类型。

- 代码实现：不唯一

  ```ts
  // 通用的交叉方法，接受不固定数量的对象
  function mergeObjects<T extends object>(...objects: T[]): T {
      return objects.reduce((merged, obj) => ({ ...merged, ...obj }), {} as T);
  }
  
  // 使用示例
  const object1 = { a: 1, b: 2 };
  const object2 = { c: 3, d: 4 };
  const object3 = { e: 5 };
  
  const mergedObject = mergeObjects(object1, object2, object3);
  // mergedObject 的类型为 { a: number, b: number, c: number, d: number, e: number }
  ```

  > **补充**
  >
  > `...`展开运算符如果遇到重名属性，后者会覆盖前者