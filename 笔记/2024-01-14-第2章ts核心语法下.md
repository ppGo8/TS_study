# ts核心语法

## ts函数类型解构

- 使用场景：

  - 当只需要使用传入的**对象部分属性时** 

  - 简化传入的参数在函数体中的写法

- 语法：在函数定义的形参处进行解构

  ```ts
  type InfoType = {
    name: string,
    age: number,
  }
  // 原方法：在函数体内部需要写全
  function getInfo(info: InfoType) {
    // 函数体中只需要使用name
    console.info(info.name);
  } 
  // 修改点：函数解构
  function getSubInfo({ name }: InfoType) { 
    console.info(name)
  }
  let objInfo = {
    name: 'pp',
    age: 24,
  }
  getInfo(objInfo);
  getSubInfo(objInfo);
  ```

## interface和type区别

- 定义类型范围：
  - `interface`：**只能定义** 1.对象类型 **2.接口当做名字的函数类型**
  - `type`：可以**定义任何类型**，基础类型、`|`联合类型、`&`交叉类型、元组。

- 继承性

  - `interface`: 

    可以`extends`继承一个或多个<font color=red>接口或类型</font>，也可以继承`type`；不过继承多个接口并不常见，继承`type`也并不常见

  - `type`: 无继承

- 是否可以交叉`&`,得到新的类型

  - `type`可以
  - `interface`不可以

- 声明是否可合并

  - `type`:定义两个同名的会出现编译错误
  - `interface`:定义连个同名的接口会**自动合并**

> 使用类型的建议：

- <font color=red>如果要定义对象，大概率使用接口</font>

  - 可以继承

  - 可以合并

    场景：如有想在`ts`底层类中添加一些自己的属性，那么只需要重写这个类即；编译器会自动合并，此时这个接口就包含了底层属性和自己自定义的属性

## 元组

### 固定元组

- 特殊的数组

  - 赋值号左侧:定义时每个元素类型确定

  - 赋值号右侧：<font color=red>数据的个数和类型</font>必须和定义的类型保持一致

  ```ts
  const tuple: [string, number, number] = ['pp', 170, 55]
  ```

- <font color=red>获得元组的值</font>

  ```ts
  // 类似数组的方法
  const tuple: [string, number, number] = ['pp', 170, 55]
  tuple[0]
  tuple[1]
  tuple[2]
  ```

### 可变元组：

- 需求：有些元素的类型和个数固定，但是有些是不固定，怎么办？

  - 数组可以吗？

    不行，因为数组是所有元素都遵守同一个类型，无法做差异化控制某个类型。

  - 解决方案：可变元素，数组和元素的结合版，<font color=red>既有元组的固定类型和个数的特点，又有数组灵活的特点</font>

- 语法：`...any[]`

  ```ts
  // 可变元组
  const customers: [string, number, number, ...any[]] = 
  ['pp', 170, 55, '广东省广州市', 'xx大学']
  ```

- <font color=red>获得可变元组的固定值和可变值</font>：**解构取值**

  ```ts
  // 如何解构获得各个元素
  const [name, height, weight, ...rest]: [string, number, number, ...any[]] = ['pp', 170, 55, '广东省广州市', '暨南大学']
  console.info(rest) // ['广东省广州市', 'xx大学']
  ```

- <font color=red>可变元组标签</font>：**作用很大，指明了可变元组该元素的含义**

  - 在类型处，每个元素的类型前面写标签

  - 标签名可以和解构名不同，但是建议: <font color=red>标签名 为 解构名添加一个下划线</font>
  - 注意：**可变元素的标签的写法**

  ```ts
  let [name, height, weight, ...rest]: [name_: string, height_: number, weight_: number, ...rest:any[]] = ['pp', 170, 55, '广东省广州市', 'xx大学']
  ```

## ts数组和数组元素同时为只读

- 数组不可改变：

  - 使用`const`声明数组后，就不可以重新使用赋值符号为数组变量重新赋值
  - 但是依旧可以使用`arr[index]`修改数组元素的值

- 数组元素不可以改变：

  - `as const`关键词，让数组元素也不可以改变

    ```ts
    const arr = [1, 2, 3, 4,] as const
    arr[0] = 6 // 报错,试图改变不可改变的元素
    ```

## 类、静态属性

- `es6`面向对象的思想还不那么彻底，比如想让一个属性变为私有就和你复杂

### 类定义

- 定义：<font color=red>拥有相同属性和方法的一系列对象的集合</font>
  - 类是模板、结构，是从这个类包含的一系列对象中**抽象出来的结构**，
  - 类**定义**了它所包含的全体对象的静态特征（属性）和动态特征（方法）

### es5实现类

- 使用构造函数完成类功能

- 实例属性直接定义在构造函数中，使用`this.xxx = 形参`的方式

  在实例方法中使用`this.xxx`访问

- 实例方法挂在在构造函数的`prototype`属性上

  因为所有的对象的方法都是一样的，只存储在一个`prototype`上，而不是都保存子啊自己的实例上，可以节省内存空间 

- 静态属性 使用`构造函数名.xxx = xxx`定义

  在静态方法和实例方法中 使用`构造函数名.xxx`来访问

- 静态方法：使用`构造函数名.xxx = function() {}`来定义

```ts
// es5实现类
function MyClassES5(name) {
  this.name = name // 实例属性
  MyClassES5.count ++;// 调用静态属性
};
// 实例方法 右侧为匿名函数
MyClassES5.prototype.getName = function() {
  return this.name
}

// 静态属性
MyClassES5.count = 0;
// 静态方法
MyClassES5.getCount = function() {
  return MyClassES5.count;
}

const n1 = new MyClassES5('pp');
console.info(MyClassES5.getCount())
const n2 = new MyClassES5('test')
console.info(MyClassES5.getCount())
```

### es6实现类

- 使用`class`定义整个类，所有的内容都是写在`class`

- 实例属性：使用构造函数`constructor`定义和接收

- 实例方法：直接写在`class`内部，建议以对象方法的方式简写

- 静态属性：`static 变量名 = xxx`

  在静态方法和实例方法中使用`类名.静态属性名`来访问

- 静态方法：直接写在`class`内部，`static 对象方法`

```js
// es6
class MyClassES6 {
  constructor(name) {
    this.name = name // 实例属性
    MyClassES6.count++;// 调用静态属性
  }
  // 实例方法
  getName() {
    return this.name
  }
  // 静态属性
  static count = 0;
  // 静态方法
  static getCount() {
    return MyClassES6.count;
  }

}
const n1 = new MyClassES6('pp');
console.info(n1.getName());
console.info(MyClassES6.getCount())
const n2 = new MyClassES6('test')
console.info(n2.getName());
console.info(MyClassES6.getCount())
```

### `ts`实现类

- 与`es6`相比,`ts`新增了<font color=red>实例属性的类型注解，`实例属性名： 类型`</font>

```ts
// ts中的写法
class MyClassTS {
  // 新增功能：实例属性的类型注释
  name: string;
  static count: number = 0; // 静态属性
  constructor (name_: string) {
    this.name = name_;
    MyClassTS.count++;
  }
  getName():string {
    return this.name;
  }
  
  // 静态方法
  static getCount():number {
    return MyClassTS.count;
  }
}

const n1 = new MyClassTS('pp');
console.info(n1.getName());
console.info(MyClassTS.getCount());
const n2 = new MyClassTS('test');
console.info(n2.getName());
console.info(MyClassTS.getCount());
```

### 什么时候使用静态成员

- 使用场景：

  - 一些**工具类**，如处理日期的工具类。所有的地方静态使用

  - 实例化之后没有用，创建对象会浪费资源、且并不需要创建对象

    但是如果开发者想实例化，也是可以实例化的并不报错。

- 实现

  使用静态成员实现工具类

  ```ts
  // 需要导出整个类给外部使用
  export default class DateUtil {
    static formateDate() {
      console.info('formateDate');
    };
    static diffDateByDay() {
      console.info('diffDateByDay');
    };
  }
  DateUtil.formateDate();
  DateUtil.diffDateByDay();
  ```

- > 静态成员工具类缺点：如果程序员想生成实例化对象还是可以生成，占用内存；存在隐患
  >
  > 工具类也可以使用<font color=red>单例模式</font>；建议使用单例模型 > 全静态成员模式

## ts 单例/件模式的两种实现

- 单例模式是设计模式的一个实现
- 单例模式：<font color=red>只允许外部获取到**类的唯一的 一个实例对象**</font>

### 立即创建单件模式

- 步骤：

  - 私有构造函数，在类内部new实例对象

  - 将工具方法写成实例方法即可

- 特点：

  `ts`解析器遇到到这个类就会立即创建这个类中的实例化的静态对象

  不管程序员是否想使用该类

```ts
// 单例模式
class DateUtil {
  // 私有化构造函数,这样这个构造函数只能在类内部被调用,
  // 即只能在类内部new,在类外部new会报错
  static dateUtil = new DateUtil(); // 立即创建,遇到这个class类就会创建静态成员；
  private constructor() {  };
  // 工具方法写成实例方法
  formateDate() {
    console.info('formateDate');
  };
  diffDateByDay() {
    console.info('diffDateByDay');
  };
}
const dateUtil1 = DateUtil.dateUtil;
const dateUtil2 = DateUtil.dateUtil;
console.info(dateUtil1 === dateUtil2);
dateUtil1.formateDate();
dateUtil1.diffDateByDay();

// 只需要导出这个对象外部即可使用
export DateUtil.dateUtil; 
```

### 方法式创建单件模式

- 步骤

  - 私有化构造函数

  - 声明静态属性的类型：该类，`static dateUtil: DateUtil`

  - 声明静态方法：里面实例化一个类对象为该类的静态属性

    ```ts
      static getInstance() { // 该函数里面还可以写一些其他的操作
        // 静态方法中的this指向类本身
        if(!this.dateUtil) {
          this.dateUtil = new DateUtil();// 只会调用一次构造函数
        }
        return this.dateUtil; // 如果已经创建了就返回旧的
    }  
    ```

  完整代码：

  ```ts
  class DateUtil {
    static dateUtil: DateUtil;
    static getInstance() { // 该函数里面还可以写一些其他的操作
      // 静态方法中的this指向类本身
      if(!this.dateUtil) {
        this.dateUtil = new DateUtil();// 只会调用一次构造函数
      }
      return this.dateUtil; // 如果已经创建了就返回旧的
    }  
    private constructor() {
      console.info('...创建对象');
    }
    // 工具类方法仍然是实例方法
    formateDate() {
      console.info('formateDate');
    };
    diffDateByDay() {
      console.info('diffDateByDay');
    };
  }
  const dateUtil1 = DateUtil.getInstance();
  const dateUtil2 = DateUtil.getInstance();
  dateUtil1.formateDate();
  console.info(dateUtil1 === dateUtil2);
  export { }
  ```

> 区分两种创建单件模式的方法：
>
> - 立即创建：书写简单，但是会马上生成唯一的实例对象
> - 方法：使用时才会创建对象，且可以在方法中定义一些其他操作

>区分静态成员工具类和单件模式：
>
>- 一个借助类来调用；外部使用时，编译器会提示很多其他原型链上的方法
>- 一个借助实例对象来调用；外部使用时，<font color=red>ts仅提示已经定义在该实例对象上的方法</font>

## ts中的getter和setter

### 作用

- 给类实例对象赋值的方法：

  - 直接赋值：

    - 类的花括号最外层写`属性名:类型 = 属性值`

    - **注意，类中直接声明属性和属性值不需要写`let`或`const`关键字**

  - 构造函数：

    - 构造函数中写`this.属性名 = xx`

  - 方法赋值：

    - `setter 属性名() {}`

    - `getter 属性名() {}`

      在花括号中使用在`class`中晟敏给的属性、

    注意：

    - <font color=red>使用方法给一个实例变量赋值，该变量必须已经从初始化并赋值</font>

    - 方法中只能识别到属性声明处、构造函数处是否有赋值；

    - 如果使用方法赋值方式判断传入值是否合法，那么只需要在声明处赋值默认值即可，在构造函数中不要再声明该属性，

    - `class`内部写`getter`和`setter`

      - 外部就使用`.`点语法和`=`赋值符号就会默认分别调用这两个方法
      
      - `getter`和`setter`后的属性不是直接存储数据的，而是给外界访问的接口
      
      - 真正操作的数据存储在另外一个变量中(一般名称为getter和setter后属性名_)
      
      
  
  > - 如果想要判断传入值是否合法，就需要使用第三种方法赋值的方式，在方法中写判断逻辑。
  >
  > - 判断值是否合法的代码不该写在构造函数中，因为不太符合编程规范，

### 代码实现

```ts
class People {
  name: string;
  _age: number = 0;
  constructor(_name: string) {
    this.name = _name;
  }
  get age() {
    return this._age; // 注意get和set提供给外界其后面的标识符;
  }
  set age(val: number) {
    if(val <= 100 && val >= 0) {
      this._age = val;
    } else {
      throw new Error('年龄不在合适范围内')
    }
  }
}

const p1 = new People('pp');
p1.age = 66;
const p2 = new People('pp2');
p2.age = 101;
```

## ts静态成员、方法拦截器

- 需求：

  - 比如要计算每个方法的执行时间、校验每一个方法传递的参数

  - 如果把这些操作写在每一个方法中很费力、很复杂

  - 希望只写一次就可以**对这些方法都应用这些操作**，<font color=red>方法拦截器</font>

- 前置知识

  - `Object.getOwnPropertyDescriptor(obj, prop)`

    - 可以返回**存储**`obj`的`prop`属性的数据属性的**新对象**

    - 数据属性：`value/writable/enumerable/configurable/getter/setter`

    - 每次调用上述方法都会为返回的数据属性开辟新的空间

      - 多次调用返回对象的引用并不相等

      - <font color=red>修改返回的新对象并不会覆盖`obj.prop`这个属性的任何内容</font>

    ```ts
    const dateProp = Object.getOwnPropertyDescriptor(People.prototype, 'doEat');
    const dateProp2 = Object.getOwnPropertyDescriptor(People.prototype, 'doEat');
    console.log(dateProp === dateProp2); // => fasle; 每次都是开辟新的空间
    console.log(dateProp); // => { value: [Function: doEat],writable: true,enumerable: false,configurable: true} 修改内容不会影响源对象的属性
    // console.log(People.prototype); // nodejs环境下为空,nodejs环境下不能直接获取需要通过方法,浏览器环境下不为空
    ```

  - `Object.defineProperty(obj, prop, value)`

    - 给`obj`的`prop`重新赋值为`value`

- 代码实现

  ```ts
  class People {
    name: string;
    age: number;
    addr: string;
    static count: number = 0;
    constructor(_name:string, _age: number, _addr: string){
      this.name = _name;
      this.age = _age;
      this.addr = _addr;
    }
    // 需求:希望在doEat调用前去做一些事情
    doEat(who: string, where: string){
      console.info(`who:${who}, where: ${where}`);
    };
    doDrink() {
  
    };
  }
  
  // 获取源方法,改造
  const dateProp = Object.getOwnPropertyDescriptor(People.prototype, 'doEat');
  const targeMethod = dateProp!.value;
  // 修改dateProp.value并没有修改class中原型上的方法
  dateProp!.value = function(...args: any[]) { 
    console.info('前置拦截');
    targeMethod.apply(this,args); // apply传递数组
    // targeMethod.call(this,args[0], args[1]); // call传递逗号分割的参数列表
    console.info('后置拦截');
  }
  // dateProp!.value('pp', 'beijing'); // 直接调用未通过实例
  
  // 实际使用是通过实例调用实例方法
  // 需要用定义的新方法覆盖原型链上的方法；实现了方法拦截
  Object.defineProperty(People.prototype, 'doEat', dateProp!); // 注意传的是整个dateProp
  let p = new People('pp', 24, '广州');
  p.doEat(p.name, p.addr); // => 前置拦截 who:pp, where: 广州 后置拦截
  export {}
  ```

  



